오늘 배운것 : 상속에 대한 전반적인 개념
상속이란? - 클래스 간의 관계, 부분집합, 
여러개 클래스의 필드,메소드 등이 반복될 경우, 그 필드, 메소드를 하나의 클래스로 묶어서 부모 클래스로 만들고 그 특성을 자식들에게 물려주는 방식 (클래스 관리가 편함)
예를 들어, 여러 동물들의 클래스(원숭이, 고래, 개, 고양이 등)가 있다면, 이 클래스의 공통적인 성질(숨을 쉰다, 밥을 먹는다 등)을 동물 클래스라는 큰 클래스에 넣어 그 성질들을 밑의 자식 클래스에게 물려줌.

java는 다중 상속이 불가능!(자식은 여럿이 가능하지만... 부모는 여럿이 불가능하다.. 여럿이면 큰일남)

상속의 특징 : 1. 오버라이딩 : 자식과 부모에 같은 이름의 메소드가 있으면(이때 리턴값이랑 매개변수, 메소드이름이 같아야됨) 자식 객체에서 그 메소드를 호출하면 부모 클래스의 메소드가 아닌 자식 클래스의 메소드가 먼저 사용되는것.
음... 예를 들면 부모클래스와 자식클래스 두개가 있는데, 둘다 walk()라는 메소드가 있다고 가정하자. 근데 부모는 그냥 걷는건데 자식들은 깡총깡총 걷는다고 해보자.
public class Parent { public void walk() {System.out.println("그냥 걷습니다.")} }
public class Child extends Parent { public void walk() {System.out.println("깡총깡총 걷습니다.")} }
이런식으로.. 근데 메인함수에서 Child라는 객체를 만들어서 walk() 메소드를 호출하면 결과값은 그냥 걷는 게 아닌 "깡총깡총 걷습니다." 가 나옴. 이런게 오버라이딩(재정의)임.

2. 자동 타입 변환(자식 객체는 부모성질 따라 간다.) : 원래 자식객체 선언하면 Child child1 = new Child(); 이런식으로 선언한다. 그러면 child1이라는 변수는 Child() 객체를 따라가면서, 타입은 Child임. 그냥 얜 Child따라감.
근데 자식 객체 선언 시, 타입은 부모로 해놓고 선언하면, 즉 Parent child2 = new Child(); 이런식으로 선언해버리면? 이 child2이라는 변수는 Child() 객체를 따라가지만 타입은 부모타입이다?? 이게 뭔 개소리일까?
child1하고 child2하고는 같은 객체를 참조하니까 일단 child1 == child2 하면 true 가 나옴 -> 왜?? 같은 객체로 선언해서! Child()로 선언했잖음
근데?? child2는 Child() 안에만 있는 메소드는 못씀!!! 왜???? 타입은 부모타입이니까 음.. 이걸 사람으로 예를들면
child1하고 child2하고 둘다 애기긴 애긴데(같은 Child() 객체 참조), child1은 전형적인 애기라 모든 애기들이 가지고 있는 특성을 갖고 있는거임(타입이 Child 참조). 뭐 super 같은거 써서 부모한테 상속 받을수도 있겠지만.. super 같은게 없이 상속이 아예 없는 건 못받음.
근데 child2는? super 안써도 부모에 있는 특성이 있는거 약간 애어른?? 느낌이라고 하면 좋을듯 그렇다고 애기들이 가지고 있는 특성이 없는것도 아니고.
그 외에도 강제 타입변환(Child child3 = (Child) Parent; / 원래 부모타입은 자식타입으로 자동변환안되는데 강제로 시켜버림. 부모가 자식성질 못쓰는데, 강제변환 시켜서 쓰게 할수 있음)같은것도 있음.
생각이 정리가 잘 안된거 같은데.. 이정도 표현해보자 일단.

3. 다형성 : 1+2로 이루어낸 객체의 다양성 -> 롤에 비유하면 좋음. 롤 각각의 챔프는 q w e r 스킬이 있는데(스킬이 있다 = 부모성질), 각 챔프마다 스킬이 다르잖음(스킬이 다르다 = 자식성질). 그런거라고 생각하면 될듯? 
그래서 자동타입변환으로 각 자식들의 성질을 호출시켜서 다형성을 이끌어냄

4. 추상 : 각 클래스를 큰 정의로 묶는 묶음 클래스라고 생각하면 좋을듯. 근데 추상적이라 밑에 자식들이 정의해줘야됨.

5. final, super, instanceof, sealed 등등
final - 마지막!! 얘는 무조건 마지막이라 부모도 안됨. 막둥이같은거 ( 클래스, 메소드 등의 종착지점 : 안바뀜 )
super - 상속하면서 오버라이딩된 부모특성을 또 쓰고싶다 근데 그 부모특성을 자식클래스에 다시 적는건 귀찮으니까 super를 이용하여 부모클래스 특성을 호출한다
instanceof - 객체 타입이 뭔지 확인하는거 아까 예를들어서 child1 instanceof Parent 하면 false 나옴(child1의 타입은 Child임 // child2의 타입이 Parent)
sealed - 밀봉한건데 자식들 많이 안낳게 하는거, 자식클래스에는 final이나 non-sealed를 붙여준다!
